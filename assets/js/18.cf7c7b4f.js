(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{426:function(v,_,T){"use strict";T.r(_);var t=T(0),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"http-1-0-（1996年）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-（1996年）"}},[v._v("#")]),v._v(" http 1.0 （1996年）")]),v._v(" "),_("p",[_("strong",[v._v("HTTP 1.0 的特点：")])]),v._v(" "),_("ul",[_("li",[v._v("任意数据类型都可以发送")]),v._v(" "),_("li",[v._v("有 GET、POST、HEAD 三种方法")]),v._v(" "),_("li",[v._v("无法复用 TCP 链接")]),v._v(" "),_("li",[v._v("有丰富的请求/响应头信息。以 header 中的 "),_("code",[v._v("Last-Modified")]),v._v(" / "),_("code",[v._v("If-Modified-Since")]),v._v("(协商缓存) 和 "),_("code",[v._v("Expirse")]),v._v("(强缓存) 作为标识")])]),v._v(" "),_("p",[v._v("影响 HTTP 网络请求的最主要因素是带宽和延迟。")]),v._v(" "),_("p",[_("strong",[v._v("HTTP 1.0 缺点：")])]),v._v(" "),_("ul",[_("li",[v._v("链接无法复用")]),v._v(" "),_("li",[v._v("队头拥塞问题")])]),v._v(" "),_("h2",{attrs:{id:"http-1-1-（1997年）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-（1997年）"}},[v._v("#")]),v._v(" http 1.1 （1997年）")]),v._v(" "),_("p",[_("strong",[v._v("HTTP 1.1 的特点：")])]),v._v(" "),_("ul",[_("li",[v._v("引入了更多的请求方法类型 "),_("code",[v._v("PUT")]),v._v(" 、"),_("code",[v._v("DELETE")]),v._v(" 、 "),_("code",[v._v("PATCH")]),v._v(" 、"),_("code",[v._v("OPTIONS")]),v._v(" 、"),_("code",[v._v("TRACE")]),v._v("、"),_("code",[v._v("CONNECT")])]),v._v(" "),_("li",[v._v("引入了长链接，TCP 默认不关闭链接，可以被多个请求复用， 通过请求头 "),_("code",[v._v("Connection: keep-alive")]),v._v(" 设置")]),v._v(" "),_("li",[v._v("引入管道链接机制，可以在同一个 TCP 链接里，发送多个请求")]),v._v(" "),_("li",[v._v("强化了缓存管理和控制，"),_("code",[v._v("Cache-Control")]),v._v("、 "),_("code",[v._v("ETag/If-None-Match")])]),v._v(" "),_("li",[v._v("支持分块响应，断点续传，利于大文件传输，能通过请求头中的 "),_("code",[v._v("Range")]),v._v(" 实现")]),v._v(" "),_("li",[v._v("使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且共享一个 IP 地址")])]),v._v(" "),_("p",[_("strong",[v._v("HTTP 1.1 中依然存在队头拥塞问题")])]),v._v(" "),_("p",[v._v("HTTP 1.1 中，管线化技术允许客户端不用等到服务器的响应就能发送下一个请求。目的是为了在 一个 TCP 链接中可以并行发送多个请求（提高网络利用率）。")]),v._v(" "),_("p",[v._v("但是还会存在一个问题，服务器必须按照请求的顺序来完成响应，也就是即使后续的请求先完成，也得等第一个请求响应发送之后，再发送后续的响应。")]),v._v(" "),_("p",[v._v("无管线化技术发送时：\n"),_("code",[v._v("请求1 -> 响应1 —> 请求2 -> 响应2 -> 请求3 -> 响应3")])]),v._v(" "),_("p",[v._v("管线化技术："),_("code",[v._v("请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3")])]),v._v(" "),_("p",[v._v("所以，如果有很多请求，前面请求响应很慢，后续的请求响应无法发送，还是会产生"),_("strong",[v._v("队头拥塞")]),v._v("的问题。")]),v._v(" "),_("p",[_("strong",[v._v("在 HTTP 1.1 中如何解决队头用塞问题")])]),v._v(" "),_("p",[_("strong",[v._v("并发链接")]),v._v("\n浏览器标准中并发链接可以有6～8个，其中 Chrome 是6个，Firefox 是8个")]),v._v(" "),_("p",[_("strong",[v._v("域名分片（域名发散）")]),v._v("\n多准备几个域名，不同的域名指向同一个服务器。")]),v._v(" "),_("p",[_("strong",[v._v("HTTP 1.1 的缺点")])]),v._v(" "),_("ul",[_("li",[v._v("高延迟带来的页面加载速度降低（还是队头阻塞问题，网络延迟问题导致这个问题没有被解决）")]),v._v(" "),_("li",[v._v("无状态特性带来巨大的 HTTP 头部")]),v._v(" "),_("li",[v._v("明文传输带来的不安全性")])]),v._v(" "),_("h2",{attrs:{id:"http-2-0-（2015年）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0-（2015年）"}},[v._v("#")]),v._v(" http 2.0 （2015年）")]),v._v(" "),_("p",[v._v("http 2.0 主要是基于 SPDY 协议。")]),v._v(" "),_("p",[v._v("SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。")]),v._v(" "),_("p",[_("strong",[v._v("HTTP 2.0 的特点：")])]),v._v(" "),_("ul",[_("li",[v._v("头部压缩")]),v._v(" "),_("li",[v._v("多路复用")]),v._v(" "),_("li",[v._v("二进制分帧层")]),v._v(" "),_("li",[v._v("服务器推送")])]),v._v(" "),_("p",[_("strong",[v._v("头部压缩")])]),v._v(" "),_("p",[v._v("在 HTTP 1.1 以以前，请求体一般会有相应的压缩编码过程，通过"),_("code",[v._v("Content-Encoding")]),v._v(" 头部字段来指定，但是对于头部字段本身的压缩是没有的。")]),v._v(" "),_("p",[v._v("HTTP 2.0 针对头部字段，也采用了对应的压缩算法 -- HPACK。\nHPACK 专门为 HTTP 2.0 服务，主要有两个特点：")]),v._v(" "),_("ul",[_("li",[v._v("先在服务端和客户端之间建立哈希表，将用到的字段存入这张表中，那么在传输的时候，对于之前出现过的值，只需要把索引（0，1，2 ...）传给对方，对方拿到索引查表就行了。这种传索引的方式，让请求头部字段得到极大程度的精简和复用。")]),v._v(" "),_("li",[v._v("其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率。")])]),v._v(" "),_("p",[_("strong",[v._v("多路复用")])]),v._v(" "),_("p",[v._v("在 HTTP 2.0 中，基于二进制分帧层，HTTP 2.0 可以在共享 TCP 链接的基础上同时发出请求和响应。HTTP 消息被分解为独立的帧，而不破坏消息的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。\n通过该技术，可以避免旧版 HTTP 版本"),_("strong",[v._v("队头阻塞")]),v._v("问题，极大提高传输性能。")]),v._v(" "),_("p",[_("strong",[v._v("二进制分桢")])]),v._v(" "),_("p",[v._v("HTTP2 认为明文传输对机器而言太麻烦了，不方便计算机的解析。于是 HTTP2 干脆把报文全部换成二进制格式，全部 01 传输，方便机器的解析。")]),v._v(" "),_("p",[v._v("原来 Headers + Body 的报文格式如今被拆分成了一个个二进制的桢，用 "),_("code",[v._v("Headers")]),v._v(" 帧存放头部字段，"),_("code",[v._v("Data")]),v._v(" 帧存放请求体数据。分桢后，服务器看到的不是一个个完整报文，而是一堆乱序的二进制帧。\n"),_("strong",[v._v("这些二进制帧不存在先后关系，因此也不会排队等待，也就没有了 HTTP 的 队头阻塞问题。")])]),v._v(" "),_("p",[v._v("所谓的乱序，"),_("strong",[v._v("指的是不同 ID 的 Stream 是乱序的")]),v._v("，但同一个 Stream ID 的桢一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。")]),v._v(" "),_("p",[_("strong",[v._v("服务器推送")])]),v._v(" "),_("p",[v._v("在 HTTP 2.0 中，服务器已经不再是被动的接收请求，响应请求。它也能新建 stream 来给客户端发送消息，当 TCP 链接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的资源文件一起返回给客户端，从而减少客户端的等待。")]),v._v(" "),_("p",[_("strong",[v._v("HTTP 2.0 的缺点：")])]),v._v(" "),_("p",[v._v("HTTP 2.0 底层还是 TCP 协议，有以下缺点：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("TCP 以及 TCP + TLS 建立链接的延时")])]),v._v(" "),_("li",[_("p",[v._v("TCP 队头拥塞的问题还是没有彻底解决。")]),v._v(" "),_("p",[v._v("HTTP2 中，多个请求是泡在一个 TCP 管道中的，当出现丢包的时候，TCP 有丢包重传的机制，所以当 HTTP2 出现丢包的时候，整个 TCP 都要开始等待重传，那么就会阻塞你 TCP 链接中的所有请求。而对于 HTTP 1.1 来说，可以开启多个 TCP 链接，出现这种情况只会影响其中一个链接，剩余的 TCP 链接还可以正常传输。")])])]),v._v(" "),_("h2",{attrs:{id:"http-3-0-（2018年）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-3-0-（2018年）"}},[v._v("#")]),v._v(" http 3.0 （2018年）")]),v._v(" "),_("p",[v._v("HTTP 3 是基于 QUIC 协议实现的。")]),v._v(" "),_("p",[v._v("QUICK 底层是基于 UDP, UDP 是无链接的，不需要握手和挥手，所以本身就比 TCP 来的快。此外 QUIC 也实现了可靠传输，保证数据一定能够抵达目的地。还引入了类似 HTTP 2 中的 “流” 和 “多路复用”，单个流是有序的，可能会因为丢包而阻塞，但是其他流不受影响。")]),v._v(" "),_("p",[_("strong",[v._v("HTTP 3 的特点：")])]),v._v(" "),_("ul",[_("li",[v._v("实现了类似 TCP 的流量控制、传输可靠性的功能\n虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。\n"),_("br")]),v._v(" "),_("li",[v._v("实现了快速握手功能\n由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。\n0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。\n"),_("br")]),v._v(" "),_("li",[v._v("集成了TLS加密功能\n"),_("br")]),v._v(" "),_("li",[v._v("多路复用，彻底解决TCP中队头阻塞的问题\n和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。")])]),v._v(" "),_("h2",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[v._v("#")]),v._v(" HTTPS")]),v._v(" "),_("p",[_("strong",[v._v("HTTPS 工作流程：")])]),v._v(" "),_("p",[v._v("HTTPS = HTTP + SSL/TLS")]),v._v(" "),_("p",[v._v("SSL 即安全套接层（Secure Sockets Layer），在 OSI 七层模型中处于会话层(第 5 层)。之前 SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 TLS（传输层安全，Transport Layer Security），并被当做 TLS1.0 的版本，准确地说，TLS1.0 = SSL3.1。")]),v._v(" "),_("p",[v._v("1、客户端请求 HTTPS 请求并连接到服务器的 443 端口，此过程和请求 HTTP 请求一样，进行三次握手；\n2、服务端向客户端发送数字证书，其中包含公钥、证书颁发者、到期日期\n现比较流行的加解密码对，即公钥和私钥。公钥用于加密，私钥用于解密。所以服务端会保留私钥，然后发送公钥给客户端。\n3、客户端收到证书，会验证证书的有效性。验证通过后会生成一个随机的 pre-master key。再将密钥通过接收到的公钥加密然后发送给服务端\n4、服务端接收后使用私钥进行解密得到 pre-master key\n5、获得 pre-master key 后，服务器和客户端可以使用主密钥进行通信。")]),v._v(" "),_("br"),v._v(" "),_("br"),v._v(" "),_("br"),v._v(" "),_("p",[v._v("参考：\nhttps://juejin.cn/post/6994629873985650696")]),v._v(" "),_("p",[v._v("https://juejin.cn/post/7031130877224550430#heading-22")])])}),[],!1,null,null,null);_.default=e.exports}}]);