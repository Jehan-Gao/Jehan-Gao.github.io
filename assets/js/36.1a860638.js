(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{444:function(t,e,l){"use strict";l.r(e);var v=l(0),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("https://time.geekbang.org/column/intro/100119601?tab=catalog")]),t._v(" "),e("p",[t._v("不可变数据：")]),t._v(" "),e("ul",[e("li",[t._v("不可变数据对象只能在创建时为属性赋值，创建后就不能修改；")]),t._v(" "),e("li",[t._v("不可变数据对象的属性也应该是不可变数据，即整个对象树都不可变；")]),t._v(" "),e("li",[t._v("变更（Mutate）不可变数据只能通过创建新对象、同时显式地指定需要变更的属性的方式，创建出的新对象依旧不可变；")]),t._v(" "),e("li",[t._v("用相同属性创建出来的两个同类型的不可变对象，它们逻辑上相等但对象引用是不相等的。")])]),t._v(" "),e("p",[t._v("React:")]),t._v(" "),e("p",[t._v("React 是用 Object.is() 方法来判断两个值是否相等的。在以下过程中，React 会调用 is(oldValue, newValue) 来对比新旧值：")]),t._v(" "),e("ul",[e("li",[t._v("更新 state 时，只有新旧 state 值不相等，才把 Fiber 标记为收到更新；")]),t._v(" "),e("li",[t._v("更新 Context.Provider 中的 value 值；")]),t._v(" "),e("li",[t._v("检查 useEffect、useMemo、useCallback 的依赖值数组，只有每个值的新老值都检查过，其中有不同时，才执行它们的回调；")]),t._v(" "),e("li",[t._v("useSyncExternalStore 中检查来自外部的应用状态（比如 Redux）是否有变化，才把 Fiber 标记为收到更新。")])])])}),[],!1,null,null,null);e.default=_.exports}}]);