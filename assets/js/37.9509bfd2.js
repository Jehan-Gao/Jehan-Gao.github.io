(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{445:function(e,t,a){"use strict";a.r(t);var v=a(0),_=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"什么是-react-fiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-react-fiber"}},[e._v("#")]),e._v(" 什么是 React Fiber")]),e._v(" "),t("p",[e._v("https://zhuanlan.zhihu.com/p/26027085")]),e._v(" "),t("p",[e._v("Fiber (纤维)")]),e._v(" "),t("p",[e._v("React Fiber 是在 React v16 提出的一种新的概念：“React Fiber是对核心算法的一次重新实现”。")]),e._v(" "),t("h2",{attrs:{id:"为什么要引入-react-fiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要引入-react-fiber"}},[e._v("#")]),e._v(" 为什么要引入 React Fiber")]),e._v(" "),t("p",[e._v("在 React v16 之前，React 的更新过程是同步的，会导致一些性能问题。")]),e._v(" "),t("p",[e._v("例如：当 React 开始要加载或更新组件树的时候，会做一些事情，包括调用各个组件的生命周期函数，计算和对比 Virtual Dom,最后更新Dom树，在这个一系列的更新过程中，React 都是同步执行操作的。")]),e._v(" "),t("p",[e._v("看似合理，但也会带来一些问题：\n当组件树特别庞大的时候，就会带来一些问题。组件嵌套特别多的时候，并且这些渲染和更新都是同步进行的，浏览器主线程一直在做这件事，直到做完它。假设用户在React更新的过程中，在页面有有一些交互操作，那么浏览器不会搭理用户的操作行为，完全被 React 同步更新操作占用着。")]),e._v(" "),t("p",[e._v("React Fiber 就是用来解决这个问题的。")]),e._v(" "),t("p",[e._v("破解JavaScript中同步操作时间过长的方法其实很简单——分片。")]),e._v(" "),t("p",[e._v("核心思路就是把一个耗时很长的任务分成很多小片，每个小片的运行时间很短，虽然总体时间很长，但是在每个小片执行完之后，都会给其他任务一个机会。\n这样的好处是：浏览器的主线程不会一直被React更新操作占着，其他任务也有运行的机会。")]),e._v(" "),t("p",[e._v("React Fiber 就是把更新过程碎片化，执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看下当前有没有紧急的任务去做，如果没有就去更新，如果有紧急任务就去做紧急任务。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/react-fiber.jpg",alt:"react-filer 执行示意图"}})]),e._v(" "),t("p",[e._v("维护每一个分片的数据结构，就是 React 中的 Fiber。")]),e._v(" "),t("p",[e._v("有了分片之后，更新过程的调用栈如下图所示，中间每一个波谷代表深入某个分片的执行过程，每个波峰就是一个分片执行结束交还控制权的时机。")]),e._v(" "),t("h2",{attrs:{id:"react-fiber-对-react-v16-代码的影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber-对-react-v16-代码的影响"}},[e._v("#")]),e._v(" React Fiber 对 React v16 代码的影响")]),e._v(" "),t("p",[e._v("在 React Fiber 中，一个更新过程会被分为很多小片，所以会存在一个更新任务没有完成，就被其他更高优先级的任务打断，此时就会先去做更高优先级的任务，而低优先级的更新任务做的工作就"),t("strong",[e._v("作废了，等待机会重新执行")]),e._v("。")]),e._v(" "),t("p",[e._v("因为一个更新过程可能被打断，所以 React Fiber  一个更新过程被分为了两个阶段（Phase）:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Reconciliation Phase\n在协调阶段，React Fiber 会找出需要更新哪些Dom, 这个阶段是可以被打断的。")])]),e._v(" "),t("li",[t("p",[e._v("Commit Phase\n在提交阶段，React Fiber 会将更新任务一鼓作气直接完成，不会被打断。")])])]),e._v(" "),t("p",[e._v("以 render 函数为界，Reconciliation Phase 阶段可能会调用以下生命周函数：")]),e._v(" "),t("ul",[t("li",[e._v("componentWillMount")]),e._v(" "),t("li",[e._v("componentWillReceiveProps")]),e._v(" "),t("li",[e._v("shouldComponentUpdate")]),e._v(" "),t("li",[e._v("componentWillUpdate")])]),e._v(" "),t("p",[e._v("Commit Phase 阶段会调用以下生命周期：")]),e._v(" "),t("ul",[t("li",[e._v("componentDidMount")]),e._v(" "),t("li",[e._v("componentDidUpdate")]),e._v(" "),t("li",[e._v("componentWillUnmount")])]),e._v(" "),t("p",[e._v("因为第一阶段的分片任务会被打断，重新执行，所以第一阶段可能会调用多次生命周期，从而导致代码出现一些意想不到的问题。")]),e._v(" "),t("p",[e._v("所以，从 React v15 升级到 React v16的时候，需要检查代码中生命周期的操作，是否有些声明周期只假设调用一次，并且这些生命周期恰好是第一阶段会调用的生命周期，那就需要重修改逻辑了，因为在 React Fiber 中有可能会出现多次调用生命周期函数的情况。")]),e._v(" "),t("p",[t("strong",[e._v("在 React V16之前，每个生命周期函数在一个加载或者更新过程中绝对只会被调用一次；在React Fiber中，不再是这样了，第一阶段中的生命周期函数在一次加载和更新过程中可能会被多次调用！")])])])}),[],!1,null,null,null);t.default=_.exports}}]);